var documenterSearchIndex = {"docs":
[{"location":"grid_integration/#Grid-Integration-Use-Case","page":"Grid Integration","title":"Grid Integration Use Case","text":"GeoACSets provides a powerful foundation for spatial energy system modeling by combining categorical data structures with geospatial capabilities.","category":"section"},{"location":"grid_integration/#The-Problem","page":"Grid Integration","title":"The Problem","text":"Utility planners face questions that require both structural and spatial reasoning:\n\n\"Where should we place new solar + storage to minimize grid congestion?\"\n\"Which feeders serve the most critical facilities?\"\n\"How does DER placement affect hosting capacity across planning zones?\"\n\"What's the upgrade cost for each substation's service territory?\"\n\nTraditional approaches use either:\n\nGIS databases: Good at spatial queries, bad at hierarchical traversal\nNetwork models: Good at topology, no spatial awareness\n\nGeoACSets bridges this gap.","category":"section"},{"location":"grid_integration/#The-Grid-as-a-Spatial-Hierarchy","page":"Grid Integration","title":"The Grid as a Spatial Hierarchy","text":"The distribution grid has a natural hierarchical structure:\n\nTransmissionZone (planning area)\n    â””â”€â”€ Substation (bulk power delivery)\n          â””â”€â”€ Feeder (distribution circuit, 4-34.5 kV)\n                â””â”€â”€ Transformer (step-down)\n                      â””â”€â”€ ServicePoint (meter)\n                            â””â”€â”€ DER (solar, storage, EV, etc.)\n\nEach level has:\n\nGeometry: service territory polygon or point location\nAttributes: capacity, loading, voltage, etc.\nMorphism to parent: structural containment relationship","category":"section"},{"location":"grid_integration/#GeoACSets-Schema","page":"Grid Integration","title":"GeoACSets Schema","text":"const SchDistributionGrid = BasicSchema(\n    [:TransmissionZone, :Substation, :Feeder, :Transformer, :ServicePoint, :DER],\n    [\n        (:substation_in, :Substation, :TransmissionZone),\n        (:feeder_at, :Feeder, :Substation),\n        (:transformer_on, :Transformer, :Feeder),\n        (:service_at, :ServicePoint, :Transformer),\n        (:der_at, :DER, :ServicePoint)\n    ],\n    # ... attributes\n)","category":"section"},{"location":"grid_integration/#Why-This-Matters","page":"Grid Integration","title":"Why This Matters","text":"","category":"section"},{"location":"grid_integration/#Query:-\"Total-DER-on-feeders-served-by-Substation-X\"","page":"Grid Integration","title":"Query: \"Total DER on feeders served by Substation X\"","text":"Without GeoACSets (spatial join):\n\nSELECT SUM(der.capacity_kw)\nFROM der\nJOIN service_point ON ST_Contains(service_point.geom, der.geom)\nJOIN transformer ON ST_Contains(transformer.service_area, service_point.geom)\nJOIN feeder ON ST_Intersects(feeder.corridor, transformer.geom)\nJOIN substation ON ST_Contains(substation.service_area, feeder.origin)\nWHERE substation.id = 'X'\n\nComplexity: O(n log n) per join, requires spatial indexes, error-prone\n\nWith GeoACSets (morphism traversal):\n\nders = ders_at_substation(grid, sub_x)\ntotal = sum(grid[d, :der_capacity_kw] for d in ders)\n\nComplexity: O(feeders + transformers + services + ders) â€” linear in result size","category":"section"},{"location":"grid_integration/#Query:-\"Cascade-outage-from-substation-to-all-affected-loads\"","page":"Grid Integration","title":"Query: \"Cascade outage from substation to all affected loads\"","text":"# Instant: follow morphisms down\naffected_services = services_at_substation(grid, failed_sub)\naffected_ders = ders_at_substation(grid, failed_sub)\n\n# For each, get hierarchical context\nfor sp in affected_services\n    xfmr = grid[sp, :service_at]\n    feeder = grid[xfmr, :transformer_on]\n    # ... handle outage propagation\nend","category":"section"},{"location":"grid_integration/#Query:-\"Find-all-loads-within-500m-of-fault-location\"","page":"Grid Integration","title":"Query: \"Find all loads within 500m of fault location\"","text":"# Spatial filter for proximity\nnearby = services_near_fault(grid, fault_lat, fault_lon, 0.5)\n\n# Then use morphisms for context\nfor sp in nearby\n    feeder = grid[grid[sp, :service_at], :transformer_on]\n    println(\"Affected: $(grid[sp, :sp_id]) on feeder $(grid[feeder, :feeder_id])\")\nend","category":"section"},{"location":"grid_integration/#Integration-with-Energy-Optimization-Tools","page":"Grid Integration","title":"Integration with Energy Optimization Tools","text":"","category":"section"},{"location":"grid_integration/#TulipaEnergyModel.jl","page":"Grid Integration","title":"TulipaEnergyModel.jl","text":"TulipaEnergyModel.jl optimizes investment and dispatch across energy systems. GeoACSets provides the spatial layer:\n\nExport topology: Each Feeder becomes a Tulipa \"hub\"\nSet constraints: Hosting capacity from GeoACSets â†’ hub import limits\nAttach assets: DERs become Tulipa producers/storage connected to hubs\nOptimize: Tulipa finds cost-optimal investment plan\nValidate: Check results against feeder/transformer limits\n\nfunction export_to_tulipa(g::DistributionGrid)\n    hubs = []\n    for feeder in parts(g, :Feeder)\n        push!(hubs, (\n            id = g[feeder, :feeder_id],\n            max_import_mw = g[feeder, :feeder_capacity_mw],\n            # location for transmission cost calculation\n        ))\n    end\n    # ... export DERs as assets connected to hubs\nend","category":"section"},{"location":"grid_integration/#REopt.jl","page":"Grid Integration","title":"REopt.jl","text":"REopt.jl optimizes DER sizing for individual sites. GeoACSets enables portfolio analysis:\n\nIdentify targets: Critical facilities in a planning zone\nRun optimization: REopt for each site\nAggregate: Sum proposed DER by feeder\nCheck constraints: Compare against hosting capacity\nIterate: Add upgrade costs or constrain if violated\n\nfunction run_portfolio_reopt(g::DistributionGrid, zone)\n    # Find critical facilities\n    critical = filter(sp -> g[sp, :sp_critical] == \"yes\", \n                      services_in_zone(g, zone))\n    \n    results = Dict()\n    for sp in critical\n        results[sp] = run_reopt(site_scenario(g, sp))\n    end\n    \n    # Check feeder constraints\n    for feeder in feeders_in_zone(g, zone)\n        proposed = sum_proposed_der(results, services_on_feeder(g, feeder))\n        if proposed > hosting_capacity(g, feeder)\n            @warn \"Feeder $(g[feeder, :feeder_id]) needs upgrade\"\n        end\n    end\nend","category":"section"},{"location":"grid_integration/#PowerModels.jl","page":"Grid Integration","title":"PowerModels.jl","text":"PowerModels.jl provides power flow and optimal power flow. GeoACSets can:\n\nBuild network: Export transformer/feeder topology to PowerModels format\nSet injections: DER generation and load from GeoACSets attributes\nRun power flow: Validate voltage/thermal limits\nUpdate state: Write results back to GeoACSets","category":"section"},{"location":"grid_integration/#Key-Advantages","page":"Grid Integration","title":"Key Advantages","text":"Capability Traditional GIS GeoACSets\n\"Which substation serves this meter?\" Spatial join O(log n) Morphism O(1)\n\"All DERs in planning zone\" Multi-table spatial join Traversal O(k)\n\"Cascade outage effects\" Complex recursive query Follow morphisms\nReferential integrity Manual enforcement Automatic (cascading delete)\nSchema enforcement Application-level Type-level","category":"section"},{"location":"grid_integration/#Example-Output","page":"Grid Integration","title":"Example Output","text":"ðŸ“Š Grid Statistics:\n  Transmission Zones: 1\n  Substations:        2\n  Feeders:            3\n  Transformers:       3\n  Service Points:     15\n  DERs:               5\n\nðŸ”Œ Substation Analysis:\n\n  Downtown Sub:\n    Load: 1.4 MW / 50.0 MVA capacity (2.8%)\n    DERs: 35.0 kW PV, 25.0 kW storage\n    Critical facilities: 2\n\nâš¡ Feeder Hosting Capacity:\n  FDR-001: 3440 kW available (60 kW installed)\n  FDR-002: 800 kW available (0 kW installed)\n  FDR-003: 4000 kW available (0 kW installed)","category":"section"},{"location":"grid_integration/#Getting-Started","page":"Grid Integration","title":"Getting Started","text":"See examples/spatial_grid_model.jl for a complete working example.\n\nusing GeoACSets\n\n# Load or build your grid model\ngrid = build_distribution_grid(...)\n\n# Query hierarchically\nfeeders = feeders_at_substation(grid, sub_id)\nservices = services_on_feeder(grid, feeder_id)\n\n# Aggregate for optimization\ntotal_load = total_load_at_substation(grid, sub_id)\nhc = hosting_capacity(grid, feeder_id)\n\n# Combine with spatial queries\nnearby = services_near_fault(grid, lat, lon, radius_km)","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Schemas","page":"API Reference","title":"Schemas","text":"","category":"section"},{"location":"api/#Spatial-Predicates","page":"API Reference","title":"Spatial Predicates","text":"","category":"section"},{"location":"api/#Traversal-Functions","page":"API Reference","title":"Traversal Functions","text":"","category":"section"},{"location":"api/#SpatialCity-Traversals","page":"API Reference","title":"SpatialCity Traversals","text":"","category":"section"},{"location":"api/#Generic-Traversals","page":"API Reference","title":"Generic Traversals","text":"","category":"section"},{"location":"api/#SpatialGraph-Traversals","page":"API Reference","title":"SpatialGraph Traversals","text":"","category":"section"},{"location":"api/#GeoACSets.SchSpatialCity","page":"API Reference","title":"GeoACSets.SchSpatialCity","text":"SchSpatialCity\n\nA 4-level spatial hierarchy: Region â†’ District â†’ Parcel â†’ Building\n\nObjects:\n\nRegion: largest administrative unit\nDistrict: subdivision of a region  \nParcel: land parcel within a district\nBuilding: structure on a parcel\n\nMorphisms (containment):\n\ndistrict_of: District â†’ Region\nparcel_of: Parcel â†’ District\nbuilding_on: Building â†’ Parcel\n\nAttributes:\n\nregiongeom, districtgeom, parcel_geom: boundary geometries\nfootprint: building footprint geometry\nregionname, districtname: string identifiers\nfloor_area: building floor area (numeric)\n\n\n\n\n\n","category":"constant"},{"location":"api/#GeoACSets.SpatialCity","page":"API Reference","title":"GeoACSets.SpatialCity","text":"SpatialCity{Geom, Name, Area}\n\nACSet type for the SpatialCity schema.\n\nType parameters:\n\nGeom: geometry type (e.g., LibGEOS.Polygon, GeoInterface.Polygon)\nName: name type (typically String or Symbol)\nArea: numeric type for floor area (typically Float64)\n\nIndexed morphisms for fast incident queries:\n\ndistrictof, parcelof, building_on\n\n\n\n\n\n","category":"type"},{"location":"api/#GeoACSets.SchSpatialGraph","page":"API Reference","title":"GeoACSets.SchSpatialGraph","text":"SchSpatialGraph\n\nA graph with spatial vertices.\n\nObjects:\n\nV: vertices with location\nE: edges connecting vertices\n\nMorphisms:\n\nsrc: E â†’ V (source vertex)\ntgt: E â†’ V (target vertex)\n\nAttributes:\n\nlocation: vertex geometry (point)\nedge_geom: edge geometry (linestring, optional)\nweight: edge weight (numeric)\n\n\n\n\n\n","category":"constant"},{"location":"api/#GeoACSets.SpatialGraph","page":"API Reference","title":"GeoACSets.SpatialGraph","text":"SpatialGraph{Geom, Weight}\n\nACSet type for the SpatialGraph schema.\n\nType parameters:\n\nGeom: geometry type for vertex locations and edge geometries\nWeight: numeric type for edge weights (typically Float64)\n\nIndexed morphisms: src, tgt\n\n\n\n\n\n","category":"type"},{"location":"api/#GeoACSets.SchParcelAdjacency","page":"API Reference","title":"GeoACSets.SchParcelAdjacency","text":"SchParcelAdjacency\n\nParcels with explicit adjacency relationships.\n\nObjects:\n\nParcel: land parcels\nAdjacency: adjacency relationships between parcels\n\nMorphisms:\n\nleft: Adjacency â†’ Parcel\nright: Adjacency â†’ Parcel\n\nAttributes:\n\nboundary: parcel boundary geometry\nshared_length: length of shared boundary (numeric)\n\n\n\n\n\n","category":"constant"},{"location":"api/#GeoACSets.ParcelAdjacency","page":"API Reference","title":"GeoACSets.ParcelAdjacency","text":"ParcelAdjacency{Geom, Length}\n\nACSet type for the ParcelAdjacency schema.\n\nType parameters:\n\nGeom: geometry type for parcel boundaries\nLength: numeric type for shared boundary length\n\nIndexed morphisms: left, right\n\n\n\n\n\n","category":"type"},{"location":"api/#GeoACSets.spatial_filter","page":"API Reference","title":"GeoACSets.spatial_filter","text":"spatial_filter(acs, object, attr, predicate) -> Vector{Int}\n\nFilter parts of object by applying predicate to their geometry attribute attr.\n\nArguments\n\nacs: the ACSet\nobject: symbol for the object type (e.g., :Building)\nattr: symbol for the geometry attribute (e.g., :footprint)\npredicate: function Geom -> Bool\n\nReturns\n\nVector of part IDs where predicate returns true.\n\nExample\n\n# Find buildings within a query polygon\nwithin_query = spatial_filter(city, :Building, :footprint, \n    geom -> LibGEOS.within(geom, query_polygon))\n\n# Find parcels intersecting a buffer\nintersecting = spatial_filter(city, :Parcel, :parcel_geom,\n    geom -> LibGEOS.intersects(geom, buffer_polygon))\n\n\n\n\n\nspatial_filter(acs, object, attr, relation, query_geom) -> Vector{Int}\n\nFilter parts by a binary spatial relation with a query geometry.\n\nArguments\n\nacs: the ACSet\nobject: symbol for the object type\nattr: symbol for the geometry attribute\nrelation: binary predicate (geom, query) -> Bool\nquery_geom: the query geometry\n\nExample\n\n# Find buildings within 100m of a point\nif HAS_LIBGEOS\n    nearby = spatial_filter(city, :Building, :footprint,\n        (g, q) -> LibGEOS.distance(g, q) < 100.0, query_point)\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.spatial_join","page":"API Reference","title":"GeoACSets.spatial_join","text":"spatial_join(acs, obj1, attr1, obj2, attr2, relation) -> Vector{Tuple{Int,Int}}\n\nFind all pairs (p1, p2) where relation(geom1, geom2) is true.\n\nArguments\n\nacs: the ACSet\nobj1, attr1: first object type and geometry attribute\nobj2, attr2: second object type and geometry attribute\nrelation: binary spatial predicate\n\nReturns\n\nVector of (part1id, part2id) tuples.\n\nExample\n\n# Find all (parcel, building) pairs where building intersects parcel\n# (This is the spatial equivalent of what morphisms give us for free!)\nif HAS_LIBGEOS\n    intersections = spatial_join(city, :Parcel, :parcel_geom, \n                                  :Building, :footprint, LibGEOS.intersects)\nend\n\nNote: For containment relationships, prefer using morphisms directly! This is O(n*m) while morphism traversal is O(k).\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.buildings_in_region","page":"API Reference","title":"GeoACSets.buildings_in_region","text":"buildings_in_region(city::SpatialCity, region_id) -> Vector{Int}\n\nFind all buildings transitively contained in a region.\n\nTraverses: Region â† District â† Parcel â† Building\n\nCost: O(d + p + b) where d, p, b are the number of districts, parcels, buildings       in the region. Compare to spatial join which is O(n log n) or worse.\n\nExample\n\ndowntown_buildings = buildings_in_region(city, downtown_id)\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.buildings_in_district","page":"API Reference","title":"GeoACSets.buildings_in_district","text":"buildings_in_district(city::SpatialCity, district_id) -> Vector{Int}\n\nFind all buildings in a district.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.parcels_in_region","page":"API Reference","title":"GeoACSets.parcels_in_region","text":"parcels_in_region(city::SpatialCity, region_id) -> Vector{Int}\n\nFind all parcels transitively contained in a region.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.parcels_in_district","page":"API Reference","title":"GeoACSets.parcels_in_district","text":"parcels_in_district(city::SpatialCity, district_id) -> Vector{Int}\n\nFind all parcels in a district.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.region_of_building","page":"API Reference","title":"GeoACSets.region_of_building","text":"region_of_building(city::SpatialCity, building_id) -> Int\n\nFind the region containing a building.\n\nTraverses: Building â†’ Parcel â†’ District â†’ Region\n\nCost: O(1) - just three morphism lookups.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.district_of_building","page":"API Reference","title":"GeoACSets.district_of_building","text":"district_of_building(city::SpatialCity, building_id) -> Int\n\nFind the district containing a building.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.region_of_parcel","page":"API Reference","title":"GeoACSets.region_of_parcel","text":"region_of_parcel(city::SpatialCity, parcel_id) -> Int\n\nFind the region containing a parcel.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.district_of_parcel","page":"API Reference","title":"GeoACSets.district_of_parcel","text":"district_of_parcel(city::SpatialCity, parcel_id) -> Int\n\nFind the district containing a parcel.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.traverse_up","page":"API Reference","title":"GeoACSets.traverse_up","text":"traverse_up(acs, part, morphisms...) -> Int\n\nFollow a chain of morphisms upward (part â†’ ... â†’ ancestor).\n\nExample\n\n# Building â†’ Parcel â†’ District â†’ Region\nregion = traverse_up(city, building_id, :building_on, :parcel_of, :district_of)\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.traverse_down","page":"API Reference","title":"GeoACSets.traverse_down","text":"traverse_down(acs, part, morphisms...) -> Vector{Int}\n\nFollow a chain of morphisms downward (ancestor â†’ ... â†’ descendants).\n\nExample\n\n# Region â†’ Districts â†’ Parcels â†’ Buildings\nbuildings = traverse_down(city, region_id, :district_of, :parcel_of, :building_on)\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.neighbors","page":"API Reference","title":"GeoACSets.neighbors","text":"neighbors(g::SpatialGraph, vertex_id) -> Vector{Int}\n\nFind all vertices adjacent to a given vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#GeoACSets.edges_between","page":"API Reference","title":"GeoACSets.edges_between","text":"edges_between(g::SpatialGraph, v1, v2) -> Vector{Int}\n\nFind all edges connecting two vertices (in either direction).\n\n\n\n\n\n","category":"function"},{"location":"#GeoACSets.jl","page":"Home","title":"GeoACSets.jl","text":"Categorical data structures with geospatial capabilities\n\nGeoACSets combines ACSets (Attributed C-Sets) with geospatial capabilities, enabling schema-aware traversal alongside spatial predicates.","category":"section"},{"location":"#Key-Insight","page":"Home","title":"Key Insight","text":"Use morphisms for structural navigation, geometry for filtering.\n\nMorphism traversal: O(k) where k = results (automatic indexing)\nSpatial join: O(n log n) with R-tree\nThe separation enables schema-aware propagation, correct cascading, homomorphism search","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"GeoACSets\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using GeoACSets\n\n# Create a city with spatial hierarchy\ncity = SpatialCity{LibGEOS.Polygon, String, Float64}()\n\n# Add a region\nr1 = add_part!(city, :Region,\n    region_name = \"Downtown\",\n    region_geom = LibGEOS.readgeom(\"POLYGON((0 0, 100 0, 100 100, 0 100, 0 0))\")\n)\n\n# Add districts within the region (morphism: district_of â†’ Region)\nd1 = add_part!(city, :District,\n    district_name = \"Financial\",\n    district_of = r1,\n    district_geom = LibGEOS.readgeom(\"POLYGON((0 0, 50 0, 50 50, 0 50, 0 0))\")\n)\n\n# Add parcels within districts\np1 = add_part!(city, :Parcel, parcel_of = d1)\n\n# Add buildings on parcels\nb1 = add_part!(city, :Building,\n    building_on = p1,\n    footprint = LibGEOS.readgeom(\"POLYGON((10 10, 40 10, 40 40, 10 40, 10 10))\"),\n    floor_area = 900.0\n)\n\n# Query via morphisms (O(1) per hop)\nbuildings = buildings_in_region(city, r1)\n\n# Upward traversal\nregion = region_of_building(city, b1)","category":"section"},{"location":"#Schemas","page":"Home","title":"Schemas","text":"","category":"section"},{"location":"#SpatialCity","page":"Home","title":"SpatialCity","text":"Hierarchical containment: Region â†’ District â†’ Parcel â†’ Building\n\nRegion â†â”€ district_of â”€ District â†â”€ parcel_of â”€ Parcel â†â”€ building_on â”€ Building","category":"section"},{"location":"#SpatialGraph","page":"Home","title":"SpatialGraph","text":"Weighted graph with vertex locations.","category":"section"},{"location":"#ParcelAdjacency","page":"Home","title":"ParcelAdjacency","text":"Parcel boundary relationships.","category":"section"},{"location":"#Why-Morphisms-Geometry?","page":"Home","title":"Why Morphisms + Geometry?","text":"Traditional spatial databases require expensive spatial joins for hierarchical queries. GeoACSets uses morphisms for O(1) structural navigation while reserving geometry for filtering:\n\n# Spatial filter, then morphism traversal\nnearby_buildings = spatial_filter(city, :Building, :footprint,\n    g -> LibGEOS.distance(g, school_geom) < 500)\n\n# Instant hierarchical context via morphisms\nfor b in nearby_buildings\n    district = traverse_up(city, b, :building_on, :parcel_of)\n    region = traverse_up(city, b, :building_on, :parcel_of, :district_of)\nend","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\"api.md\"]","category":"section"}]
}
